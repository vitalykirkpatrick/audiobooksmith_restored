import os
import json
from pathlib import Path
from openai import OpenAI

# --- Configuration ---
# The P-01 blocker was resolved, allowing us to use the OpenAI API.
# The API key is available via the environment variable OPENAI_API_KEY.
CLIENT = OpenAI() 

PROJECT_ROOT = Path("/home/ubuntu/audiobooksmith_project")
PROMPT_FILE = PROJECT_ROOT / "data" / "prompts" / "narration_prompts.json"
INPUT_DIR = PROJECT_ROOT / "output" / "extracted_chapters"
OUTPUT_DIR = PROJECT_ROOT / "output" / "narration_ready"

# Ensure output directory exists
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

def load_narration_prompt(prompt_path: Path) -> dict:
    """Loads the structured prompt data generated by Phase 3."""
    if not prompt_path.exists():
        print(f"Error: Prompt file not found at {prompt_path}")
        return None
    with open(prompt_path, 'r', encoding='utf-8') as f:
        return json.load(f)

def create_full_system_prompt(prompt_data: dict) -> str:
    """
    Constructs the final, detailed system prompt for the LLM, including all rules.
    """
    system_prompt = prompt_data.get("system_prompt", "You are an expert linguistic editor.")
    
    # 1. Linguistic Substitution Rules
    sub_table = prompt_data.get("linguistic_substitution_table", {})
    linguistic_rules = "Linguistic Substitution Rules:\n"
    for category, items in sub_table.items():
        linguistic_rules += f"\n- {category.upper()} Substitutions:\n"
        for item in items:
            if 'cyrillic' in item:
                linguistic_rules += f"  - Replace all instances of '{item['english']}' with '{item['cyrillic']}'.\n"
            elif 'narration_rule' in item:
                linguistic_rules += f"  - Replace all instances of '{item['english']}' with the full phrase: '{item['narration_rule']}'.\n"

    # 2. Unit Conversion Rules
    unit_table = prompt_data.get("unit_conversion_table", [])
    unit_rules = "\nUnit Conversion Rules (First Use Only):\n"
    for unit in unit_table:
        unit_rules += f"  - Replace '{unit['original']}' with the expanded phrase: '{unit['rewrite']}'.\n"

    # 3. SSML/Pacing Rules (LLM is instructed to apply these where appropriate)
    ssml_rules = "\nSSML/Pacing Rules (Apply where appropriate, do not output SSML tags):\n"
    for rule in prompt_data.get("ssml_pacing_rules", []):
        ssml_rules += f"  - {rule['context']}: Use pacing/tone appropriate for the context.\n"

    return f"{system_prompt}\n\n{linguistic_rules}\n{unit_rules}\n{ssml_rules}"

def apply_local_substitutions(chapter_text: str, prompt_data: dict) -> str:
    """Performs non-negotiable Cyrillic and Unit substitutions locally."""
    
    # 1. Linguistic Substitution Rules (Names, Places, Cultural Terms)
    sub_table = prompt_data.get("linguistic_substitution_table", {})
    for category, items in sub_table.items():
        for item in items:
            original = item['english']
            replacement = item.get('cyrillic') or item.get('narration_rule')
            
            if replacement:
                # Use simple string replace for now, as the LLM will handle the final polish
                chapter_text = chapter_text.replace(original, replacement)

    # 2. Unit Conversion Rules
    unit_table = prompt_data.get("unit_conversion_table", [])
    for unit in unit_table:
        chapter_text = chapter_text.replace(unit['original'], unit['rewrite'])
        
    return chapter_text

def rewrite_chapter_with_ai(chapter_text: str, system_prompt: str) -> str:
    """
    Calls the OpenAI API to rewrite a single chapter based on the system prompt.
    """
    print("Calling AI API to rewrite chapter...")
    try:
        response = CLIENT.chat.completions.create(
            model="gpt-4.1-mini", # Using a fast, capable model for this task
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": f"Rewrite the following chapter text based on the rules provided:\n\n---\n\n{chapter_text}"}
            ],
            temperature=0.1 # Low temperature for precise, rule-based rewriting
        )
        return response.choices[0].message.content
    except Exception as e:
        print(f"An error occurred during AI call: {e}")
        return f"ERROR: AI Rewriting Failed. Original Text: {chapter_text}"

def main():
    """Main function to orchestrate the chapter rewriting process."""
    prompt_data = load_narration_prompt(PROMPT_FILE)
    if not prompt_data:
        return

    system_prompt = create_full_system_prompt(prompt_data)
    
    # Process each extracted chapter
    for chapter_file in INPUT_DIR.glob("*.txt"):
        print(f"\nProcessing chapter: {chapter_file.name}")
        
        # 1. Load Chapter Text
        with open(chapter_file, 'r', encoding='utf-8') as f:
            original_text = f.read()
        
        # 2. Apply Local Substitutions (Cyrillic, Units)
        substituted_text = apply_local_substitutions(original_text, prompt_data)
        
        # 3. Rewrite with AI (Tonal/Flow Polish)
        rewritten_text = rewrite_chapter_with_ai(substituted_text, system_prompt)
        
        # 4. Save Rewritten Chapter
        output_file = OUTPUT_DIR / chapter_file.name
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(rewritten_text)
        
        print(f"Successfully saved rewritten chapter to {output_file}")
        
        # For demonstration, only process the target chapter
        if chapter_file.name == "03_ONCE_UPON_A_TIME.txt":
            print("\n--- Demonstration Complete (Processed one chapter) ---")
            break

if __name__ == "__main__":
    main()
